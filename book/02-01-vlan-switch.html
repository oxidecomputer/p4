<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>VLAN Switch - The x4c Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The x4c Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="vlan-switch"><a class="header" href="#vlan-switch">VLAN Switch</a></h1>
<p>This example presents a simple VLAN switch program. This program allows a single
VLAN id (<code>vid</code>) to be set per port. Any packet arriving at a port with a <code>vid</code>
set must carry that <code>vid</code> in its Ethernet header or it will be dropped. We’ll
refer to this as VLAN filtering. If a packet makes it past ingress filtering,
then the forwarding table of the switch is consulted to see what port to send
the packet out. We limit ourselves to a very simple switch here with a static
forwarding table. A MAC learning switch will be presented in a later example.
This switch also does not do flooding for unknown packets, it simply operates on
the lookup table it has. If an egress port is identified via a forwarding table
lookup, then egress VLAN filtering is applied. If the <code>vid</code> on the packet is
present on the egress port then the packet is forwarded out that port.</p>
<p>This example is comprised of two programs. A P4 data-plane program and a Rust
control-plane program.</p>
<h2 id="p4-data-plane-program"><a class="header" href="#p4-data-plane-program">P4 Data-Plane Program</a></h2>
<p>Let’s start by taking a look at the headers for the P4 program.</p>
<pre><code class="language-p4">header ethernet_h {
    bit&lt;48&gt; dst;
    bit&lt;48&gt; src;
    bit&lt;16&gt; ether_type;
}

header vlan_h {
    bit&lt;3&gt; pcp;
    bit&lt;1&gt; dei;
    bit&lt;12&gt; vid;
    bit&lt;16&gt; ether_type;
}

struct headers_t {
    ethernet_h eth;
    vlan_h vlan;
}
</code></pre>
<p>An Ethernet frame is normally just 14 bytes with a 6 byte source and destination
plus a two byte ethertype. However, when VLAN tags are present the ethertype is
set to <code>0x8100</code> and a VLAN header follows. This header contains a 12-bit <code>vid</code>
as well as an ethertype for the header that follows.</p>
<p>A byte-oriented packet diagram shows how these two Ethernet frame variants line
up.</p>
<pre><code>                     1
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8
+---------------------------+
|    src    |    dst    |et |
+---------------------------+
+-----------------------------------+
|    src    |    dst    |et |pdv|et |
+------------------------------------
</code></pre>
<p>The structure is always the same for the first 14 bytes. So we can take
advantage of that when parsing any type of Ethernet frame. Then we can use the
ethertype field to determine if we are looking at a regular Ethernet frame or a
VLAN-tagged Ethernet frame.</p>
<pre><code class="language-p4">parser parse (
    packet_in pkt,
    out headers_t h,
    inout ingress_metadata_t ingress,
) {
    state start {
        pkt.extract(h.eth);
        if (h.eth.ether_type == 16w0x8100) { transition vlan; } 
        transition accept;
    }
    state vlan {
        pkt.extract(h.vlan);
        transition accept;
    }
}
</code></pre>
<p>This parser does exactly what we described above. First parse the first 14 bytes
of the packet as an Ethernet frame. Then conditionally parse the VLAN portion of
the Ethernet frame if the ethertype indicates we should do so. In a sense we can
think of the VLAN portion of the Ethernet frame as being it’s own independent
header. We are keying our decisions based on the ethertype, just as we would for
layer 3 protocol headers.</p>
<p>Our VLAN switch P4 program is broken up into multiple control blocks. We’ll
start with the top level control block and then dive into the control blocks it
calls into to implement the switch.</p>
<pre><code class="language-p4">control ingress(
    inout headers_t hdr,
    inout ingress_metadata_t ingress,
    inout egress_metadata_t egress,
) {
    vlan() vlan;
    forward() fwd;
    
    apply {
        bit&lt;12&gt; vid = 12w0;
        if (hdr.vlan.isValid()) {
            vid = hdr.vlan.vid;
        }

        // check vlan on ingress
        bool vlan_ok = false;
        vlan.apply(ingress.port, vid, vlan_ok);
        if (vlan_ok == false) {
            egress.drop = true;
            return;
        }

        // apply switch forwarding logic
        fwd.apply(hdr, ingress, egress);

        // check vlan on egress
        vlan.apply(egress.port, vid, vlan_ok);
        if (vlan_ok == false) {
            egress.drop = true;
            return;
        }
    }
}
</code></pre>
<p>The first thing that is happening in this program is the instantiation of a few
other control blocks.</p>
<pre><code class="language-p4">vlan() vlan;
forward() fwd;
</code></pre>
<p>We’ll be using these control blocks to implement the VLAN filtering and switch
forwarding logic. For now let’s take a look at the higher level packet
processing logic of the program in the <code>apply</code> block.</p>
<p>The first thing we do is start by assuming there is no <code>vid</code> by setting it to
zero. The if the VLAN header is valid we assign the <code>vid</code> from the packet header
to our local <code>vid</code> variable. The <code>isValid</code> header method returns <code>true</code> if
<code>extract</code> was called on that header. Recall from the parser code above, that
<code>extract</code> is only called on <code>hdr.vlan</code> if the ethertype on the Ethernet frame is
<code>0x1800</code>.</p>
<pre><code class="language-p4">bit&lt;12&gt; vid = 12w0;
if (hdr.vlan.isValid()) {
    vid = hdr.vlan.vid;
}
</code></pre>
<p>Next apply VLAN filtering logic. First an indicator variable <code>vlan_ok</code> is
initialized to false. Then we pass that indicator variable along with the port
the packet came in on and the <code>vid</code> we determined above to the VLAN control
block.</p>
<pre><code class="language-p4">bool vlan_ok = false;
vlan.apply(ingress.port, vid, vlan_ok);
if (vlan_ok == false) {
    egress.drop = true;
    return;
}
</code></pre>
<p>Let’s take a look at the VLAN control block. The first thing to note here is the
direction of parameters. The <code>port</code> and <code>vid</code> parameters are <code>in</code> parameters,
meaning that the control block can only read from them. The <code>match</code> parameter is
an <code>out</code> parameter meaning the control block can only write to it. Consider this
in the context of the code above. There we are passing in the <code>vlan_ok</code> to the
control block with the expectation that the control block will modify the value
of the variable. The <code>out</code> direction of this control block parameter is what
makes that possible.</p>
<pre><code class="language-p4">control vlan(
    in bit&lt;16&gt; port,
    in bit&lt;12&gt; vid,
    out bool match,
) {
    action no_vid_for_port() {
        match = true;
    }

    action filter(bit&lt;12&gt; port_vid) { 
        if (port_vid == vid) { match = true; } 
    }
    
    table port_vlan {
        key             = { port: exact; }
        actions         = { no_vid_for_port; filter; }
        default_action  = no_vid_for_port;
    }

    apply { port_vlan.apply(); }
}
</code></pre>
<p>Let’s look at this control block starting from the <code>table</code> declaration. The
<code>port_vlan</code> table has the <code>port</code> id as the single key element. There are two
possible actions <code>no_vid_for_port</code> and <code>filter</code>. The <code>no_vid_for_port</code> fires
when there is no match for the <code>port</code> id. That action unconditionally sets
<code>match</code> to true. The logic here is that if there is no VLAN configure for a port
e.g., the port is not in the table, then there is no need to do any VLAN
filtering and just pass the packet along.</p>
<p>The <code>filter</code> action takes a single parameter <code>port_vid</code>. This value is populated
by the table value entry corresponding to the <code>port</code> key. There are no static
table entries in this P4 program, they are provided by a control plane program
which we’ll get to in a bit. The <code>filter</code> logic tests if the <code>port_vid</code> that has
been configured by the control plane matches the <code>vid</code> on the packet. If the
test passes then <code>match</code> is set to true meaning the packet can continue
processing.</p>
<p>Popping back up to the top level control block. If <code>vlan_ok</code> was not set to
<code>true</code> in the <code>vlan</code> control block, then we drop the packet. Otherwise we
continue on to further processing - forwarding.</p>
<p>Here we are passing the entire header, and ingress and egress metadata structures into the
<code>fwd</code> control block which is an instantiation of the <code>forward</code> control block
type.</p>
<pre><code class="language-p4">fwd.apply(hdr, ingress, egress);
</code></pre>
<p>Lets take a look at the <code>forward</code> control block.</p>
<pre><code class="language-p4">control forward(
    inout headers_t hdr,
    inout ingress_metadata_t ingress,
    inout egress_metadata_t egress,
) {
    action drop() { ingress.drop = true; }
    action forward(bit&lt;16&gt; port) { egress.port = port; }

    table fib {
        key             = { hdr.eth.dst: exact; }
        actions         = { drop; forward; }
        default_action  = drop;
    }

    apply { fib.apply(); }
}
</code></pre>
<p>This simple control block contains a table that maps Ethernet addresses to
ports. The single element key contains an Ethernet destination and the matching
action <code>forward</code> contains a single 16-bit port value.  When the Ethernet
destination matches an entry in the table, the egress metadata destination for
the packet is set to the port id that has been set for that table entry.</p>
<p>Note that in this control block all parameters have an <code>inout</code> direction,
meaning the control block can both read from and write to these parameters.
Like the <code>vlan</code> control block above, there are no static entries here. Entries
for the table in this control block are filled in by a control-plane program.</p>
<p>Popping back up the stack to our top level control block, the remaining code we
have is the following.</p>
<pre><code class="language-p4">vlan.apply(egress.port, vid, vlan_ok);
if (vlan_ok == false) {
    egress.drop = true;
    return;
}
</code></pre>
<p>This is pretty much the same as what we did at the beginning of the apply block.
Except this time, we are passing in the egress port instead of the ingress port.
We are checking the VLAN tags not only for the ingress port, but also for the
egress port.</p>
<p>You can find this program in it’s entirety
<a href="https://github.com/oxidecomputer/p4/blob/main/book/code/src/bin/vlan-switch.p4">here</a>.</p>
<h2 id="rust-control-plane-program"><a class="header" href="#rust-control-plane-program">Rust Control-Plane Program</a></h2>
<p>The main purpose of the Rust control plane program is to manage table entries in
the P4 program. In addition to table management, the program we’ll be showing
here also instantiates and runs the P4 code over a virtual ASIC to demonstrate
the complete system working.</p>
<p>We’ll start top down again. Here is the beginning of our Rust program.</p>
<pre><code class="language-rust">use tests::expect_frames;
use tests::softnpu::{RxFrame, SoftNpu, TxFrame};

const NUM_PORTS: u16 = 2;

p4_macro::use_p4!(
    p4 = "book/code/src/bin/vlan-switch.p4",
    pipeline_name = "vlan_switch"
);

fn main() -&gt; Result&lt;(), anyhow::Error&gt; {
    let mut pipeline = main_pipeline::new(NUM_PORTS);

    let m1 = [0x33, 0x33, 0x33, 0x33, 0x33, 0x33];
    let m2 = [0x44, 0x44, 0x44, 0x44, 0x44, 0x44];

    init_tables(&amp;mut pipeline, m1, m2);
    run_test(pipeline, m2)
}</code></pre>
<p>After imports, the first thing we are doing is calling the <code>use_p4!</code> macro. This
translates our P4 program into Rust and expands the <code>use_p4!</code> macro in place to
the generated Rust code. This results in the <code>main_pipeline</code> type that we see
instantiated in the first line of the <code>main</code> program. Then we define a few MAC
addresses that we’ll get back to later. The remainder of the <code>main</code> code
performs the two functions described above. The <code>init_tables</code> function acts as a
control plane for our P4 code, setting up the VLAN and forwarding tables. The
<code>run_test</code> code executes our instantiated pipeline over a virtual ASIC, sends
some packets through it, and makes assertions about the results.</p>
<h3 id="control-plane-code"><a class="header" href="#control-plane-code">Control Plane Code</a></h3>
<p>Let’s jump into the control plane code.</p>
<pre><code class="language-rust">fn init_tables(pipeline: &amp;mut main_pipeline, m1: [u8;6], m2: [u8;6]) {
    // add static forwarding entries
    pipeline.add_ingress_fwd_fib_entry("forward", &amp;m1, &amp;0u16.to_be_bytes());
    pipeline.add_ingress_fwd_fib_entry("forward", &amp;m2, &amp;1u16.to_be_bytes());

    // port 0 vlan 47
    pipeline.add_ingress_vlan_port_vlan_entry(
        "filter",
        0u16.to_be_bytes().as_ref(),
        47u16.to_be_bytes().as_ref(),
    );

    // sanity check the table
    let x = pipeline.get_ingress_vlan_port_vlan_entries();
    println!("{:#?}", x);

    // port 1 vlan 47
    pipeline.add_ingress_vlan_port_vlan_entry(
        "filter",
        1u16.to_be_bytes().as_ref(),
        47u16.to_be_bytes().as_ref(),
    );

}</code></pre>
<p>The first thing that happens here is the forwarding tables are set up. We add
two entries one for each MAC address. The first MAC address maps to the first
port and the second MAC address maps to the second port.</p>
<p>We are using table modification methods from the Rust code that was generated
from our P4 code. A valid question is, how do I know what these are? There are
two ways.</p>
<h4 id="determine-based-on-p4-code-structure"><a class="header" href="#determine-based-on-p4-code-structure">Determine Based on P4 Code Structure</a></h4>
<p>The naming is deterministic based on the structure of the p4 program. Table
modification functions follow the pattern
<code>&lt;operation&gt;_&lt;control_path&gt;_&lt;table_name&gt;_entry</code>. Where <code>operation</code> one of the
following.</p>
<ul>
<li><code>add</code></li>
<li><code>remove</code></li>
<li><code>get</code>.</li>
</ul>
<p>The <code>control_path</code> is based on the names of control instances starting from the
top level ingress controller. In our P4 program, the forwarding table is named
<code>fwd</code> so that is what we see in the function above. If there is a longer chain
of controller instances, the instance names are underscore separated. Finally
the <code>table_name</code> is the name of the table in the control block. This is how we
arrive at the method name above.</p>
<pre><code class="language-rust">pipeline.add_fwd_fib_entry(...)</code></pre>
<h4 id="use-cargo-doc"><a class="header" href="#use-cargo-doc">Use <code>cargo doc</code></a></h4>
<p>Alternatively you can just run <code>cargo doc</code> to have Cargo generate documentation
for your crate that contains the P4-generated Rust code. This will emit Rust
documentation that includes documentation for the generated code.</p>
<p>For example, in the main p4 repository that contains the vlan switch example
code, when you run <code>cargo doc</code> you’ll see something like this</p>
<pre><code>$ cargo doc
[snip]
 Documenting x4c_error_codes v0.1.0 (/Users/ry/src/p4/x4c_error_codes)
 Documenting clap v3.2.23
 Documenting tests v0.1.0 (/Users/ry/src/p4/test)
 Documenting sidecar-lite v0.1.0 (/Users/ry/src/p4/lang/prog/sidecar-lite)
 Documenting p4-macro-test v0.1.0 (/Users/ry/src/p4/lang/p4-macro-test)
 Documenting x4c-book v0.1.0 (/Users/ry/src/p4/book/code)
 Documenting x4c v0.1.0 (/Users/ry/src/p4/x4c)
    Finished dev [unoptimized + debuginfo] target(s) in 15.87s
   Generated /Users/ry/src/p4/target/doc/p4_macro/index.html
   Generated /Users/ry/src/p4/target/doc/p4_macro_test/index.html
   Generated /Users/ry/src/p4/target/doc/p4_rust/index.html
   Generated /Users/ry/src/p4/target/doc/p4rs/index.html
   Generated /Users/ry/src/p4/target/doc/sidecar_lite/index.html
   Generated /Users/ry/src/p4/target/doc/tests/index.html
   Generated /Users/ry/src/p4/target/doc/x4c/index.html
   Generated /Users/ry/src/p4/target/doc/hello_world/index.html
   Generated /Users/ry/src/p4/target/doc/vlan_switch/index.html
   Generated /Users/ry/src/p4/target/doc/x4c_error_codes/index.html
</code></pre>
<p>If you open the file <code>target/doc/vlan_switch/index.html</code>. You’ll see several
struct and function definitions. In particular, if you click on the
<code>main_pipeline</code> struct, you’ll see methods associated with the main pipeline
like <code>add_ingress_fwd_fib_entry</code> that allow you to modify pipeline table state.</p>
<p>Now back to the control plane code above. You’ll also notice that we are adding
key values and parameter values to the P4 tables as byte slices. At the time of
writing, <code>x4c</code> is not generating high-level table manipulation APIs so we have
to pass everything in as binary serialized data.</p>
<p>The semantics of these data buffers are the following.</p>
<ol>
<li>Both key data and match action data (parameters) are passed in in-order.</li>
<li>Numeric types are serialized in big-endian byte order.</li>
<li>If a set of keys or a set of parameters results in a size that does not land
on a byte-boundary, i.e. 12 bytes like we have in this example, the length of
the buffer is rounded up to the nearest byte boundary.</li>
</ol>
<p>After adding the forwarding entries, VLAN table entries are added in the same
manner. A VLAN with the <code>vid</code> of <code>47</code> is added to the first and second ports.
Note that we also use a table access method to get all the entries of a table
and print them out to convince ourselves our code is doing what we intend.</p>
<h3 id="test-code"><a class="header" href="#test-code">Test Code</a></h3>
<p>Now let’s take a look at the test portion of our code.</p>
<pre><code class="language-rust">fn run_test(
    pipeline: main_pipeline,
    m2: [u8; 6],
    m3: [u8; 6],
) -&gt; Result&lt;(), anyhow::Error&gt; {
    // create and run the softnpu instance
    let mut npu = SoftNpu::new(NUM_PORTS.into(), pipeline, false);
    let phy1 = npu.phy(0);
    let phy2 = npu.phy(1);
    npu.run();

    // send a packet we expect to make it through
    phy1.send(&amp;[TxFrame::newv(m2, 0, b"blueberry", 47)])?;
    expect_frames!(phy2, &amp;[RxFrame::newv(phy1.mac, 0x8100, b"blueberry", 47)]);

    // send 3 packets, we expect the first 2 to get filtered by vlan rules
    phy1.send(&amp;[TxFrame::newv(m2, 0, b"poppyseed", 74)])?; // 74 != 47
    phy1.send(&amp;[TxFrame::new(m2, 0, b"banana")])?; // no tag
    phy1.send(&amp;[TxFrame::newv(m2, 0, b"muffin", 47)])?;
    phy1.send(&amp;[TxFrame::newv(m3, 0, b"nut", 47)])?; // no forwarding entry
    expect_frames!(phy2, &amp;[RxFrame::newv(phy1.mac, 0x8100, b"muffin", 47)]);

    Ok(())
}</code></pre>
<p>The first thing we do here is create a <code>SoftNpu</code> virtual ASIC instance with 2
ports that will execute the pipeline we configured with entries in the previous
section. We get references to each ASIC port and run the ASIC.</p>
<p>Next we send a few packets through the ASIC to validate that our P4 program is
doing what we expect given how we have configured the tables.</p>
<p>The first test passes through a packet we expect to make it through the VLAN
filtering. The next test sends 4 packets in the ASIC, but we expect our P4
program to filter 3 of them out.</p>
<ul>
<li>The first packet has the wrong <code>vid</code>.</li>
<li>The second packet has no <code>vid</code>.</li>
<li>The third packet should make it through.</li>
<li>The fourth packet has no forwarding entry.</li>
</ul>
<h4 id="running-the-test"><a class="header" href="#running-the-test">Running the test</a></h4>
<p>When we run this program we see the following</p>
<pre><code class="language-bash">$ cargo run --bin vlan-switch
    Finished dev [unoptimized + debuginfo] target(s) in 0.11s
     Running `target/debug/vlan-switch`
[
    TableEntry {
        action_id: "filter",
        keyset_data: [
            0,
            0,
        ],
        parameter_data: [
            0,
            47,
        ],
    },
]
[phy2] blueberry
drop
drop
drop
[phy2] muffin
</code></pre>
<p>The first thing we see is our little sanity check dumping out the VLAN table
after adding a single entry. This has what we expect, mapping the port <code>0</code> to
the <code>vid</code> <code>47</code>.</p>
<p>Next we start sending packets through the ASIC. There are two frame constructors
in play here. <code>TxFrame::newv</code> creates an Ethernet frame with a VLAN header and
<code>TxFrame::new</code> creates just a plane old Ethernet frame. The first argument to
each frame constructor is the destination MAC address. The second argument is
the ethertype to use and the third argument is the Ethernet payload.</p>
<p>Next we see that our blueberry packet made it through as expected. Then we see
three packets getting dropped as we expect. And finally we see the muffin packet
coming through as expected.</p>
<p>You can find this program in it’s entirety
<a href="https://github.com/oxidecomputer/p4/blob/main/book/code/src/bin/vlan-switch.rs">here</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="02-by-example.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="03-guidelines.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="02-by-example.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="03-guidelines.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="https://storage.googleapis.com/goodwu-public/highlight.min.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
