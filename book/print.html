<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The x4c Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The x4c Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-x4c-book"><a class="header" href="#the-x4c-book">The x4c Book</a></h1>
<p>This book provides an introduction to the P4 language using the <code>x4c</code> compiler.
The presentation is by example. Each concept is introduced through example P4
code and programs - then demonstrated using simple harnesses that pass packets
through compiled P4 pipelines.</p>
<p>A basic knowledge of programming and networking is assumed. The <code>x4c</code> Rust
compilation target will be used in this book, so a working knowledge of
<a href="https://www.rust-lang.org/">Rust</a> is also good to have.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-basics"><a class="header" href="#the-basics">The Basics</a></h1>
<p>This chapter will take you from zero to a simple hello-world program in P4.
This will include.</p>
<ul>
<li>Getting a Rust toolchain setup and installing the <code>x4c</code> compiler.</li>
<li>Compiling a P4 hello world program into a Rust program.</li>
<li>Writing a bit of Rust code to push packets through the our compiled P4
pipelines.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<p>The first thing we'll need to do is install Rust. We'll be using a tool called
<a href="https://rustup.rs/">rustup</a>. On Unix/Linux like platforms, simply run the
following from your terminal. For other platforms see the rustup docs.</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>It may be necessary to restart your shell session after installing Rust.</p>
<h2 id="x4c"><a class="header" href="#x4c"><code>x4c</code></a></h2>
<p>Now we will install the <code>x4c</code> compiler using the rust <code>cargo</code> tool.</p>
<pre><code class="language-bash">cargo install --git https://github.com/oxidecomputer/p4 x4c
</code></pre>
<p>You should now be able to run <code>x4c</code>.</p>
<pre><code>x4c --help
x4c 0.1

USAGE:
    x4c [OPTIONS] &lt;FILENAME&gt; [TARGET]

ARGS:
    &lt;FILENAME&gt;    File to compile
    &lt;TARGET&gt;      What target to generate code for [default: rust] [possible values: rust,
                  red-hawk, docs]

OPTIONS:
        --check          Just check code, do not compile
    -h, --help           Print help information
    -o, --out &lt;OUT&gt;      Filename to write generated code to [default: out.rs]
        --show-ast       Show parsed abstract syntax tree
        --show-hlir      Show high-level intermediate representation info
        --show-pre       Show parsed preprocessor info
        --show-tokens    Show parsed lexical tokens
    -V, --version        Print version information
</code></pre>
<p>That's it! We're now ready to dive into P4 code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>Let's start out our introduction of P4 with the obligatory hello world program.</p>
<h2 id="parsing"><a class="header" href="#parsing">Parsing</a></h2>
<p>The first bit of programmable logic packets hit in a P4 program is a parser.
Parsers do the following.</p>
<ol>
<li>Describe a state machine packet parsing.</li>
<li>Extract raw data into headers with typed fields.</li>
<li>Decide if a packet should be accepted or rejected based on parsed structure.</li>
</ol>
<p>In the code below, we can see that parsers are defined somewhat like functions
in general-purpose programming languages. They take a set of parameters and have
a curly-brace delimited block of code that acts over those parameters.</p>
<p>Each of the parameters has an optional direction that we see here as <code>out</code> or
<code>inout</code>, a type, and a name. We'll get to data types in the next section for now
let's focus on what this parser code is doing.</p>
<p>The parameters shown here are typical of what you will see for P4 parsers. The
exact set of parameters varies depending on ASIC the P4 code is being compiled
for. But in general, there will always need to be - a packet, set of headers to
extract packet data into and a bit of metadata about the packet that the ASIC
has collected.</p>
<pre><code class="language-p4">parser parse (
    packet_in pkt,
    out headers_t headers,
    inout ingress_metadata_t ingress,
){
    state start {
        pkt.extract(headers.ethernet);
        transition finish;
    }

    state finish {
        transition accept;
    }
}
</code></pre>
<p>Parsers are made up of a set of states and transitions between those states.
<strong><em>Parsers must always include a <code>start</code> state</em></strong>. Our start state extracts an
Ethernet header from the incoming packet and places it in to the <code>headers_t</code>
parameter passed to the parser. We then transition to the <code>finish</code> state where
we simply transition to the implicit <code>accept</code> state. We could have just
transitioned to <code>accept</code> from <code>start</code>, but wanted to show transitions between
user-defined states in this example.</p>
<p>Transitioning to the <code>accept</code> state means that the packet will be passed to a
control block for further processing. Control blocks will be covered a few
sections from now. Parsers can also transition to the implicit <code>reject</code> state.
This means that the packet will be dropped and not go on to any further
processing.</p>
<h2 id="data-types"><a class="header" href="#data-types">Data Types</a></h2>
<p>There are two primary data types in P4, <code>struct</code> and <code>header</code> types.</p>
<h3 id="structs"><a class="header" href="#structs">Structs</a></h3>
<p>Structs in P4 are similar to structs you'll find in general purpose programming
languages such as C, Rust, and Go. They are containers for data with typed data
fields. They can contain basic data types, headers as well as other structs.</p>
<p>Let's take a look at the structs in use by our hello world program.</p>
<p>The first is a structure containing headers for our program to extract packet
data into. This <code>headers_t</code> structure is simple and only contains one header.
However, there may be an arbitrary number of headers in the struct. We'll
discuss headers in the next section.</p>
<pre><code class="language-p4">struct headers_t {
    ethernet_t ethernet;
}
</code></pre>
<p>The next structure is a bit of metadata provided to our parser by the ASIC. In
our simple example this just includes the port that the packet came from. So if
our code is running on a four port switch, the <code>port</code> field would take on a
value between <code>0</code> and <code>3</code> depending on which port the packet came in on.</p>
<pre><code class="language-p4">struct ingress_metadata_t {
    bit&lt;16&gt; port;
}
</code></pre>
<p>As the name suggests <code>bit&lt;16&gt;</code> is a 16-bit value. In P4 the <code>bit&lt;N&gt;</code> type
commonly represents unsigned integer values. We'll get more into the primitive
data types of P4 later.</p>
<h3 id="headers"><a class="header" href="#headers">Headers</a></h3>
<p>Headers are the result of parsing packets. They are similar in nature to
structures with the following differences.</p>
<ol>
<li>Headers may not contain headers.</li>
<li>Headers have a set of methods <code>isValid()</code>, <code>setValid()</code>, and <code>setValid()</code>
that provide a means for parsers and control blocks to coordinate on the
parsed structure of packets as they move through pipelines.</li>
</ol>
<p>Let's take a look at the <code>ethernet_h</code> header in our hello world example.</p>
<pre><code class="language-p4">header ethernet_h {
    bit&lt;48&gt; dst;
    bit&lt;48&gt; src;
    bit&lt;16&gt; ether_type;
}
</code></pre>
<p>This header represents a layer-2
<a href="https://en.wikipedia.org/wiki/Ethernet_frame">Ethernet frame</a>.
The leading octet is not present as this will be removed by most ASICs. What
remains is the MAC source and destination fields which are each 6 octets / 48
bits and the ethertype which is 2 octets.</p>
<p>Note also that the payload is not included here. This is important. P4 programs
typically operate on packet headers and not packet payloads. In upcoming
examples we'll go over header stacks that include headers at higher layers like
IP, ICMP and TCP.</p>
<p>In the parsing code above, when <code>pkt.extract(headers.ethernet)</code> is called, the
values <code>dst</code>, <code>src</code> and <code>ether_type</code> are populated from packet data and the
method <code>setValid()</code> is implicitly called on the <code>headers.ethernet</code> header.</p>
<h3 id="control-blocks"><a class="header" href="#control-blocks">Control Blocks</a></h3>
<p>Control blocks are where logic goes that decides what will happen to packets
that are parsed successfully. Similar to a parser block, control blocks look a
lot like functions from general purpose programming languages. The signature
(the number and type of arguments) for this control block is a bit different
than the parser block above.</p>
<p>The first argument <code>hdr</code>, is the output of the parser block. Note in the parser
signature there is a <code>out headers_t headers</code> parameter, and in this control
block there is a <code>inout headers_t hdr</code> parameter. The <code>out</code> direction in the
parser means that the parser writes to this parameter. The <code>inout</code> direction
in the control block means that the control both reads and writes to this
parameter.</p>
<p>The <code>ingress_metadata_t</code> parameter is the same parameter we saw in the parser
block.  The <code>egress_metadata_t</code> is similar to <code>ingress_metadata_t</code>. However,
our code uses this parameter to inform the ASIC about how it should treat packets
on egress. This is in contrast to the <code>ingress_metdata_t</code> parameter that is used
by the ASIC to inform our program about details of the packet's ingress.</p>
<pre><code class="language-p4">control ingress(
    inout headers_t hdr,
    inout ingress_metadata_t ingress,
    inout egress_metadata_t egress,
) {

    action drop() {
		ingress.drop = true;
	}

    action forward(bit&lt;16&gt; port) {
        egress.port = port;
    }

    table tbl {
        key = {
            ingress.port: exact;
        }
        actions = {
            drop;
            forward;
        }
        default_action = drop;
        const entries = {
            16w0 : forward(16w1);
            16w1 : forward(16w0);
        }
    }

    apply {
        tbl.apply();
    }

}
</code></pre>
<p>Control blocks are made up of tables, actions and apply blocks. When packet
headers enter a control block, the <code>apply</code> block decides what tables to run the
parameter data through. Tables are described in terms if keys and actions. A
<code>key</code> is an ordered sequence of fields that can be extracted from any of the
control parameters. In the example above we are using the <code>port</code> field from the
<code>ingress</code> parameter to decide what to do with a packet. We are not even
investigating the packet headers at all! We can indeed use header fields in
keys, and an example of doing so will come later.</p>
<p>When a table is applied, and there is an entry in the table that matches the key
data, the action corresponding to that key is executed. In our example we have
pre-populated our table with two entries. The first entry says, if the ingress
port is <code>0</code>, forward the packet to port <code>1</code>. The second entry says if the ingress
port is <code>1</code>, forward the packet to port <code>0</code>. These odd looking prefixes on our
numbers are width specifiers. So <code>16w0</code> reads: the value <code>0</code> with a width of 16
bits.</p>
<p>Every action that is specified in a table entry must be defined within the
control. In our example, the <code>forward</code> action is defined above. All this action
does is set the <code>port</code> field on the egress metadata to the provided value.</p>
<p>The example table also has a default action of <code>drop</code>. This action fires for all
invocations of the table over key data that has no matching entry. So for our
program, any packet coming from a port that is not <code>0</code> or <code>1</code> will be dropped.</p>
<p>The apply block is home to generic procedural code. In our example it's very
simple and only has an <code>apply</code> invocation for our table. However, arbitrary
logic can go in this block, we could even implement the logic of this control
without a table!</p>
<pre><code class="language-p4">apply {
    if (ingress.port == 16w0) {
        egress.port = 16w1;
    }
    if (ingress.port == 16w1) {
        egress.port = 16w0;
    }
}
</code></pre>
<p>Which then begs the question, why have a special table construct at all. Why not
just program everything using logical primitives? Or let programmers define
their own data structures like general purpose programming languages do?</p>
<p>Setting the performance arguments aside for the moment, there is something
mechanically special about tables. They can be updated from outside the P4
program. In the program above we have what are called constant entries defined
directly in the P4 program. This makes presenting a simple program like this
very straight forward, but it is not the way tables are typically populated. The
focus of P4 is on data plane programming e.g., given a packet from the wire what
do we do with it? I prime example of this is packet routing and forwarding.</p>
<p>Both routing and forwarding are typically implemented in terms of lookup tables.
Routing is commonly implemented by longest prefix matching on the destination
address of an IP packet and forwarding is commonly implemented by exact table
lookups on layer-2 MAC addresses. How are those lookup tables populated though.
There are various different answers there. Some common ones include routing
protocols like OSPF, or BGP. Address resolution protocols like ARP and NDP. Or
even more simple answers like an administrator statically adding a route to the
system.</p>
<p>All of these activities involve either a stateful protocol of some sort or
direct interaction with a user. Neither of those things is possible in the P4
programming language. It's just about processing packets on the wire and the
mechanisms for keeping state between packets is extremely limited.</p>
<p>What P4 implementations <strong><em>do</em></strong> provide is a way for programs written in
general purpose programming languages that <strong><em>are</em></strong> capable of stateful
protocol implementation and user interaction - to modify the tables of a running
P4 program through a runtime API. We'll come back to runtime APIs soon. For now
the point is that the table abstraction allows P4 programs to remain focused on
simple, mostly-stateless packet processing tasks that can be implemented at high
packet rates and leave the problem of table management to the general purpose
programming languages that interact with P4 programs through shared table
manipulation.</p>
<h2 id="package"><a class="header" href="#package">Package</a></h2>
<p>The final bit to show for our hello world program is a package instantiation.
A package is like a constructor function that takes a parser and a set of
control blocks. Packages are typically tied to the ASIC your P4 code will be
executing on. In the example below, we are passing our parser and single control
block to the <code>SoftNPU</code> package. Packages for more complex ASICs may take many
control blocks as arguments.</p>
<pre><code class="language-p4">SoftNPU(
    parse(),
    ingress()
) main;
</code></pre>
<h2 id="full-program"><a class="header" href="#full-program">Full Program</a></h2>
<p>Putting it all together, we have a complete P4 hello world program as follows.</p>
<pre><code class="language-p4">struct headers_t {
    ethernet_h ethernet;
}

struct ingress_metadata_t {
    bit&lt;16&gt; port;
    bool drop;
}

struct egress_metadata_t {
    bit&lt;16&gt; port;
    bool drop;
    bool broadcast;
}

header ethernet_h {
    bit&lt;48&gt; dst;
    bit&lt;48&gt; src;
    bit&lt;16&gt; ether_type;
}

parser parse (
    packet_in pkt,
    out headers_t headers,
    inout ingress_metadata_t ingress,
){
    state start {
        pkt.extract(headers.ethernet);
        transition finish;
    }

    state finish {
        transition accept;
    }
}

control ingress(
    inout headers_t hdr,
    inout ingress_metadata_t ingress,
    inout egress_metadata_t egress,
) {

    action drop() { }

    action forward(bit&lt;16&gt; port) {
        egress.port = port;
    }

    table tbl {
        key = {
            ingress.port: exact;
        }
        actions = {
            drop;
            forward;
        }
        default_action = drop;
        const entries = {
            16w0 : forward(16w1);
            16w1 : forward(16w0);
        }
    }

    apply {
        tbl.apply();
    }

}

// We do not use an egress controller in this example, but one is required for
// SoftNPU so just use an empty controller here.
control egress(
    inout headers_t hdr,
    inout ingress_metadata_t ingress,
    inout egress_metadata_t egress,
) {

}

SoftNPU(
    parse(),
    ingress(),
    egress(),
) main;
</code></pre>
<p>This program will take any packet that has an Ethernet header showing up on port
<code>0</code>, send it out port <code>1</code>, and vice versa. All other packets will be dropped.</p>
<p>In the next section we'll compile this program and run some packets through it!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compile-and-run"><a class="header" href="#compile-and-run">Compile and Run</a></h1>
<p>In the previous section we put together a hello world P4 program. In this
section we run that program over a software ASIC called SoftNpu. One of the
capabilities of the <code>x4c</code> compiler is using P4 code directly from Rust code
and we'll be doing that in this example.</p>
<p>Below is a Rust program that imports the P4 code developed in the last section,
loads it onto a SoftNpu ASIC instance, and sends some packets through it.  We'll
be looking at this program piece-by-piece in the remainder of this section.</p>
<p>All of the programs in this book are available as buildable programs in the
<a href="https://github.com/oxidecomputer/p4">oxidecomputer/p4</a> repository in the
<code>book/code</code> directory.</p>
<pre><code class="language-rust">use tests::softnpu::{RxFrame, SoftNpu, TxFrame};
use tests::{expect_frames};

const NUM_PORTS: u16 = 3;

p4_macro::use_p4!(p4 = "book/code/src/bin/hello-world.p4", pipeline_name = "hello");

fn main() -&gt; Result&lt;(), anyhow::Error&gt; {
    let pipeline = main_pipeline::new(NUM_PORTS);
    let mut npu = SoftNpu::new(NUM_PORTS, pipeline, false);
    let phy1 = npu.phy(0);
    let phy2 = npu.phy(1);
    let phy3 = npu.phy(2);

    npu.run();

    // Expect this packet to be dropped
    phy3.send(&amp;[TxFrame::new(phy3.mac, 0, b"to the bit bucket with you!")])?;

    phy1.send(&amp;[TxFrame::new(phy2.mac, 0, b"hello")])?;
    expect_frames!(phy2, &amp;[RxFrame::new(phy1.mac, 0, b"hello")]);

    phy2.send(&amp;[TxFrame::new(phy1.mac, 0, b"world")])?;
    expect_frames!(phy1, &amp;[RxFrame::new(phy2.mac, 0, b"world")]);

    Ok(())
}</code></pre>
<p>The program starts with a few Rust imports.</p>
<pre><code class="language-rust">use tests::softnpu::{RxFrame, SoftNpu, TxFrame};
use tests::{expect_frames};</code></pre>
<p>This first line is the SoftNpu implementation that lives in the <code>test</code> crate of
the <code>oxidecomputer/p4</code> repository. The second is a helper macro that allows us
to make assertions about frames coming from a SoftNpu "physical" port (referred
to as a phy).</p>
<p>The next line is using the <code>x4c</code> compiler to translate P4 code into Rust code
and dumping that Rust code into our program. The macro literally expands into
the Rust code emitted by the compiler for the specified P4 source file.</p>
<pre><code class="language-rust">p4_macro::use_p4!(p4 = "book/code/src/bin/hello-world.p4", pipeline_name = "hello");</code></pre>
<p>The main artifact this produces is a Rust <code>struct</code> called <code>main_pipeline</code> which is used
in the code that comes next.</p>
<pre><code class="language-rust">let pipeline = main_pipeline::new(NUM_PORTS);
let mut npu = SoftNpu::new(NUM_PORTS, pipeline, false);
let phy1 = npu.phy(0);
let phy2 = npu.phy(1);
let phy3 = npu.phy(2);</code></pre>
<p>This code is instantiating a pipeline object that encapsulates the logic of our
P4 program. Then a SoftNpu ASIC is constructed with three ports and our pipeline
program. SoftNpu objects provide a <code>phy</code> method that takes a port index to get a
reference to a port that is attached to the ASIC. These port objects are used to
send and receive packets through the ASIC, which uses our compiled P4 code to
process those packets.</p>
<p>Next we run our program on the SoftNpu ASIC.</p>
<pre><code class="language-rust">npu.run();</code></pre>
<p>However, this does not actually do anything until we pass some packets through
it, so lets do that.</p>
<pre><code class="language-rust">// Expect this packet to be dropped
phy3.send(&amp;[TxFrame::new(phy3.mac, 0, b"to the bit bucket with you!")])?;</code></pre>
<p>This code transmit an Ethernet frame through the third port of the
ASIC with a payload value of "to the bit bucket with you!".  The
<code>phy3.mac</code> parameter of the <code>TxFrame</code> sets the destination MAC address
and the <code>0</code> for the second parameter is the ethertype used in the
outgoing Ethernet frame.</p>
<p>Based on the logic in our P4 program, we would expect this packet to
be dropped by the switch, i.e. it will not be sent out of any port at
all.  This is because the table lookup on the ingress port value of 2
would get a miss, and the table would execute the default action
<code>drop</code>.  Thus we do not call <code>expect_frames!</code> here, as we do for the
test packets below.</p>
<pre><code class="language-rust">phy1.send(&amp;[TxFrame::new(phy2.mac, 0, b"hello")])?;</code></pre>
<p>This code transmits an Ethernet frame through the first port of the ASIC with a
payload value of <code>"hello"</code>.</p>
<p>Based on the logic in our P4 program, we would expect this packet to come out
the second port. Let's test that.</p>
<pre><code class="language-rust">expect_frames!(phy2, &amp;[RxFrame::new(phy1.mac, 0, b"hello")]);</code></pre>
<p>This code reads a packet from the second ASIC port <code>phy2</code> (blocking until there
is a packet available) and asserts the following.</p>
<ul>
<li>The Ethernet payload is the byte string <code>"hello"</code>.</li>
<li>The source MAC address is that of <code>phy1</code>.</li>
<li>The ethertype is <code>0</code>.</li>
</ul>
<p>To complete the hello world program, we do the same thing in the opposite
direction. Sending the byte string <code>"world"</code> as an Ethernet payload into port 2
and assert that it comes out port 1.</p>
<pre><code class="language-rust">phy2.send(&amp;[TxFrame::new(phy1.mac, 0, b"world")])?;
expect_frames!(phy1, &amp;[RxFrame::new(phy2.mac, 0, b"world")]);</code></pre>
<p>The <code>expect_frames</code> macro will also print payloads and the port they came from.</p>
<p>When we run this program we see the following.</p>
<pre><code class="language-bash">$ cargo run --bin hello-world
   Compiling x4c-book v0.1.0 (/home/ry/src/p4/book/code)
    Finished dev [unoptimized + debuginfo] target(s) in 2.05s
     Running `target/debug/hello-world`
[phy2] hello
[phy1] world
</code></pre>
<h2 id="softnpu-and-target-x4c-use-cases"><a class="header" href="#softnpu-and-target-x4c-use-cases">SoftNpu and Target <code>x4c</code> Use Cases.</a></h2>
<p>The example above shows using <code>x4c</code> compiled code is a setting that is only
really useful for testing the logic of compiled pipelines and demonstrating how
P4 and <code>x4c</code> compiled pipelines work. This begs the question of what the target
use cases for <code>x4c</code> actually are. It also raises question, why build <code>x4c</code> in the
first place? Why not use the established reference compiler <code>p4c</code> and its
associated reference behavioral model <code>bmv2</code>?</p>
<p><em>A key difference between <code>x4c</code> and the <code>p4c</code> ecosystem is how compilation
and execution concerns are separated. <code>x4c</code> generates free-standing pipelines
that can be used by other code, <code>p4c</code> generates JSON that is interpreted and run
by <code>bmv2</code></em>.</p>
<p>The example above shows how the generation of free-standing runnable pipelines
can be used to test the logic of P4 programs in a lightweight way. We went from
P4 program source to actual packet processing using nothing but the Rust
compiler and package manager. The program is executable in an operating system
independent way and is a great way to get CI going for P4 programs.</p>
<p>The free-standing pipeline approach is not limited to self-contained use cases
with packets that are generated and consumed in-program. <code>x4c</code> generated code
conforms to a well defined
<a href="https://oxidecomputer.github.io/p4/p4rs/index.html"><code>Pipeline</code></a>
interface that can be used to run pipelines anywhere <code>rustc</code> compiled code can
run. Pipelines are even dynamically loadable through <code>dlopen</code> and the like.</p>
<p>The <code>x4c</code> authors have used <code>x4c</code> generated pipelines to create virtual ASICs
inside hypervisors that transit real traffic between virtual machines, as well
as P4 programs running inside zones/containers that implement NAT and tunnel
encap/decap capabilities. The mechanics of I/O are deliberately outside the
scope of <code>x4c</code> generated code. Whether you want to use DLPI, XDP, libpcap,
PF_RING, DPDK, etc., is up to you and the harness code you write around your
pipelines!</p>
<p>The win with <code>x4c</code> is flexibility. You can compile a free-standing P4 pipeline
and use that pipeline wherever you see fit. The near-term use for <code>x4c</code> focuses
on development and evaluation environments. If you are building a system around
P4 programmable components, but it's not realistic to buy all the
switches/routers/ASICs at the scale you need for testing/development, <code>x4c</code> is an
option. <code>x4c</code> is also a good option for running packets through your pipelines
in a lightweight way in CI.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="by-example"><a class="header" href="#by-example">By Example</a></h1>
<p>This chapter presents the use of the P4 language and <code>x4c</code> through a series of
examples. This is a living set that will grow over time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vlan-switch"><a class="header" href="#vlan-switch">VLAN Switch</a></h1>
<p>This example presents a simple VLAN switch program. This program allows a single
VLAN id (<code>vid</code>) to be set per port. Any packet arriving at a port with a <code>vid</code>
set must carry that <code>vid</code> in its Ethernet header or it will be dropped. We'll
refer to this as VLAN filtering. If a packet makes it past ingress filtering,
then the forwarding table of the switch is consulted to see what port to send
the packet out. We limit ourselves to a very simple switch here with a static
forwarding table. A MAC learning switch will be presented in a later example.
This switch also does not do flooding for unknown packets, it simply operates on
the lookup table it has. If an egress port is identified via a forwarding table
lookup, then egress VLAN filtering is applied. If the <code>vid</code> on the packet is
present on the egress port then the packet is forwarded out that port.</p>
<p>This example is comprised of two programs. A P4 data-plane program and a Rust
control-plane program.</p>
<h2 id="p4-data-plane-program"><a class="header" href="#p4-data-plane-program">P4 Data-Plane Program</a></h2>
<p>Let's start by taking a look at the headers for the P4 program.</p>
<pre><code class="language-p4">header ethernet_h {
    bit&lt;48&gt; dst;
    bit&lt;48&gt; src;
    bit&lt;16&gt; ether_type;
}

header vlan_h {
    bit&lt;3&gt; pcp;
    bit&lt;1&gt; dei;
    bit&lt;12&gt; vid;
    bit&lt;16&gt; ether_type;
}

struct headers_t {
    ethernet_h eth;
    vlan_h vlan;
}
</code></pre>
<p>An Ethernet frame is normally just 14 bytes with a 6 byte source and destination
plus a two byte ethertype. However, when VLAN tags are present the ethertype is
set to <code>0x8100</code> and a VLAN header follows. This header contains a 12-bit <code>vid</code>
as well as an ethertype for the header that follows.</p>
<p>A byte-oriented packet diagram shows how these two Ethernet frame variants line
up.</p>
<pre><code>                     1
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8
+---------------------------+
|    src    |    dst    |et |
+---------------------------+
+-----------------------------------+
|    src    |    dst    |et |pdv|et |
+------------------------------------
</code></pre>
<p>The structure is always the same for the first 14 bytes. So we can take
advantage of that when parsing any type of Ethernet frame. Then we can use the
ethertype field to determine if we are looking at a regular Ethernet frame or a
VLAN-tagged Ethernet frame.</p>
<pre><code class="language-p4">parser parse (
    packet_in pkt,
    out headers_t h,
    inout ingress_metadata_t ingress,
) {
    state start {
        pkt.extract(h.eth);
        if (h.eth.ether_type == 16w0x8100) { transition vlan; } 
        transition accept;
    }
    state vlan {
        pkt.extract(h.vlan);
        transition accept;
    }
}
</code></pre>
<p>This parser does exactly what we described above. First parse the first 14 bytes
of the packet as an Ethernet frame. Then conditionally parse the VLAN portion of
the Ethernet frame if the ethertype indicates we should do so. In a sense we can
think of the VLAN portion of the Ethernet frame as being it's own independent
header. We are keying our decisions based on the ethertype, just as we would for
layer 3 protocol headers.</p>
<p>Our VLAN switch P4 program is broken up into multiple control blocks. We'll
start with the top level control block and then dive into the control blocks it
calls into to implement the switch.</p>
<pre><code class="language-p4">control ingress(
    inout headers_t hdr,
    inout ingress_metadata_t ingress,
    inout egress_metadata_t egress,
) {
    vlan() vlan;
    forward() fwd;
    
    apply {
        bit&lt;12&gt; vid = 12w0;
        if (hdr.vlan.isValid()) {
            vid = hdr.vlan.vid;
        }

        // check vlan on ingress
        bool vlan_ok = false;
        vlan.apply(ingress.port, vid, vlan_ok);
        if (vlan_ok == false) {
            egress.drop = true;
            return;
        }

        // apply switch forwarding logic
        fwd.apply(hdr, ingress, egress);

        // check vlan on egress
        vlan.apply(egress.port, vid, vlan_ok);
        if (vlan_ok == false) {
            egress.drop = true;
            return;
        }
    }
}
</code></pre>
<p>The first thing that is happening in this program is the instantiation of a few
other control blocks.</p>
<pre><code class="language-p4">vlan() vlan;
forward() fwd;
</code></pre>
<p>We'll be using these control blocks to implement the VLAN filtering and switch
forwarding logic. For now let's take a look at the higher level packet
processing logic of the program in the <code>apply</code> block.</p>
<p>The first thing we do is start by assuming there is no <code>vid</code> by setting it to
zero. The if the VLAN header is valid we assign the <code>vid</code> from the packet header
to our local <code>vid</code> variable. The <code>isValid</code> header method returns <code>true</code> if
<code>extract</code> was called on that header. Recall from the parser code above, that
<code>extract</code> is only called on <code>hdr.vlan</code> if the ethertype on the Ethernet frame is
<code>0x1800</code>.</p>
<pre><code class="language-p4">bit&lt;12&gt; vid = 12w0;
if (hdr.vlan.isValid()) {
    vid = hdr.vlan.vid;
}
</code></pre>
<p>Next apply VLAN filtering logic. First an indicator variable <code>vlan_ok</code> is
initialized to false. Then we pass that indicator variable along with the port
the packet came in on and the <code>vid</code> we determined above to the VLAN control
block.</p>
<pre><code class="language-p4">bool vlan_ok = false;
vlan.apply(ingress.port, vid, vlan_ok);
if (vlan_ok == false) {
    egress.drop = true;
    return;
}
</code></pre>
<p>Let's take a look at the VLAN control block. The first thing to note here is the
direction of parameters. The <code>port</code> and <code>vid</code> parameters are <code>in</code> parameters,
meaning that the control block can only read from them. The <code>match</code> parameter is
an <code>out</code> parameter meaning the control block can only write to it. Consider this
in the context of the code above. There we are passing in the <code>vlan_ok</code> to the
control block with the expectation that the control block will modify the value
of the variable. The <code>out</code> direction of this control block parameter is what
makes that possible.</p>
<pre><code class="language-p4">control vlan(
    in bit&lt;16&gt; port,
    in bit&lt;12&gt; vid,
    out bool match,
) {
    action no_vid_for_port() {
        match = true;
    }

    action filter(bit&lt;12&gt; port_vid) { 
        if (port_vid == vid) { match = true; } 
    }
    
    table port_vlan {
        key             = { port: exact; }
        actions         = { no_vid_for_port; filter; }
        default_action  = no_vid_for_port;
    }

    apply { port_vlan.apply(); }
}
</code></pre>
<p>Let's look at this control block starting from the <code>table</code> declaration. The
<code>port_vlan</code> table has the <code>port</code> id as the single key element. There are two
possible actions <code>no_vid_for_port</code> and <code>filter</code>. The <code>no_vid_for_port</code> fires
when there is no match for the <code>port</code> id. That action unconditionally sets
<code>match</code> to true. The logic here is that if there is no VLAN configure for a port
e.g., the port is not in the table, then there is no need to do any VLAN
filtering and just pass the packet along.</p>
<p>The <code>filter</code> action takes a single parameter <code>port_vid</code>. This value is populated
by the table value entry corresponding to the <code>port</code> key. There are no static
table entries in this P4 program, they are provided by a control plane program
which we'll get to in a bit. The <code>filter</code> logic tests if the <code>port_vid</code> that has
been configured by the control plane matches the <code>vid</code> on the packet. If the
test passes then <code>match</code> is set to true meaning the packet can continue
processing.</p>
<p>Popping back up to the top level control block. If <code>vlan_ok</code> was not set to
<code>true</code> in the <code>vlan</code> control block, then we drop the packet. Otherwise we
continue on to further processing - forwarding.</p>
<p>Here we are passing the entire header, and ingress and egress metadata structures into the
<code>fwd</code> control block which is an instantiation of the <code>forward</code> control block
type.</p>
<pre><code class="language-p4">fwd.apply(hdr, ingress, egress);
</code></pre>
<p>Lets take a look at the <code>forward</code> control block.</p>
<pre><code class="language-p4">control forward(
    inout headers_t hdr,
    inout ingress_metadata_t ingress,
    inout egress_metadata_t egress,
) {
    action drop() { ingress.drop = true; }
    action forward(bit&lt;16&gt; port) { egress.port = port; }

    table fib {
        key             = { hdr.eth.dst: exact; }
        actions         = { drop; forward; }
        default_action  = drop;
    }

    apply { fib.apply(); }
}
</code></pre>
<p>This simple control block contains a table that maps Ethernet addresses to
ports. The single element key contains an Ethernet destination and the matching
action <code>forward</code> contains a single 16-bit port value.  When the Ethernet
destination matches an entry in the table, the egress metadata destination for
the packet is set to the port id that has been set for that table entry.</p>
<p>Note that in this control block all parameters have an <code>inout</code> direction,
meaning the control block can both read from and write to these parameters.
Like the <code>vlan</code> control block above, there are no static entries here. Entries
for the table in this control block are filled in by a control-plane program.</p>
<p>Popping back up the stack to our top level control block, the remaining code we
have is the following.</p>
<pre><code class="language-p4">vlan.apply(egress.port, vid, vlan_ok);
if (vlan_ok == false) {
    egress.drop = true;
    return;
}
</code></pre>
<p>This is pretty much the same as what we did at the beginning of the apply block.
Except this time, we are passing in the egress port instead of the ingress port.
We are checking the VLAN tags not only for the ingress port, but also for the
egress port.</p>
<p>You can find this program in it's entirety
<a href="https://github.com/oxidecomputer/p4/blob/main/book/code/src/bin/vlan-switch.p4">here</a>.</p>
<h2 id="rust-control-plane-program"><a class="header" href="#rust-control-plane-program">Rust Control-Plane Program</a></h2>
<p>The main purpose of the Rust control plane program is to manage table entries in
the P4 program. In addition to table management, the program we'll be showing
here also instantiates and runs the P4 code over a virtual ASIC to demonstrate
the complete system working.</p>
<p>We'll start top down again. Here is the beginning of our Rust program.</p>
<pre><code class="language-rust">use tests::expect_frames;
use tests::softnpu::{RxFrame, SoftNpu, TxFrame};

const NUM_PORTS: u16 = 2;

p4_macro::use_p4!(
    p4 = "book/code/src/bin/vlan-switch.p4",
    pipeline_name = "vlan_switch"
);

fn main() -&gt; Result&lt;(), anyhow::Error&gt; {
    let mut pipeline = main_pipeline::new(NUM_PORTS);

    let m1 = [0x33, 0x33, 0x33, 0x33, 0x33, 0x33];
    let m2 = [0x44, 0x44, 0x44, 0x44, 0x44, 0x44];

    init_tables(&amp;mut pipeline, m1, m2);
    run_test(pipeline, m2)
}</code></pre>
<p>After imports, the first thing we are doing is calling the <code>use_p4!</code> macro. This
translates our P4 program into Rust and expands the <code>use_p4!</code> macro in place to
the generated Rust code. This results in the <code>main_pipeline</code> type that we see
instantiated in the first line of the <code>main</code> program. Then we define a few MAC
addresses that we'll get back to later. The remainder of the <code>main</code> code
performs the two functions described above. The <code>init_tables</code> function acts as a
control plane for our P4 code, setting up the VLAN and forwarding tables. The
<code>run_test</code> code executes our instantiated pipeline over a virtual ASIC, sends
some packets through it, and makes assertions about the results.</p>
<h3 id="control-plane-code"><a class="header" href="#control-plane-code">Control Plane Code</a></h3>
<p>Let's jump into the control plane code.</p>
<pre><code class="language-rust">fn init_tables(pipeline: &amp;mut main_pipeline, m1: [u8;6], m2: [u8;6]) {
    // add static forwarding entries
    pipeline.add_ingress_fwd_fib_entry("forward", &amp;m1, &amp;0u16.to_be_bytes());
    pipeline.add_ingress_fwd_fib_entry("forward", &amp;m2, &amp;1u16.to_be_bytes());

    // port 0 vlan 47
    pipeline.add_ingress_vlan_port_vlan_entry(
        "filter",
        0u16.to_be_bytes().as_ref(),
        47u16.to_be_bytes().as_ref(),
    );

    // sanity check the table
    let x = pipeline.get_ingress_vlan_port_vlan_entries();
    println!("{:#?}", x);

    // port 1 vlan 47
    pipeline.add_ingress_vlan_port_vlan_entry(
        "filter",
        1u16.to_be_bytes().as_ref(),
        47u16.to_be_bytes().as_ref(),
    );

}</code></pre>
<p>The first thing that happens here is the forwarding tables are set up. We add
two entries one for each MAC address. The first MAC address maps to the first
port and the second MAC address maps to the second port.</p>
<p>We are using table modification methods from the Rust code that was generated
from our P4 code. A valid question is, how do I know what these are? There are
two ways.</p>
<h4 id="determine-based-on-p4-code-structure"><a class="header" href="#determine-based-on-p4-code-structure">Determine Based on P4 Code Structure</a></h4>
<p>The naming is deterministic based on the structure of the p4 program. Table
modification functions follow the pattern
<code>&lt;operation&gt;_&lt;control_path&gt;_&lt;table_name&gt;_entry</code>. Where <code>operation</code> one of the
following.</p>
<ul>
<li><code>add</code></li>
<li><code>remove</code></li>
<li><code>get</code>.</li>
</ul>
<p>The <code>control_path</code> is based on the names of control instances starting from the
top level ingress controller. In our P4 program, the forwarding table is named
<code>fwd</code> so that is what we see in the function above. If there is a longer chain
of controller instances, the instance names are underscore separated. Finally
the <code>table_name</code> is the name of the table in the control block. This is how we
arrive at the method name above.</p>
<pre><code class="language-rust">pipeline.add_fwd_fib_entry(...)</code></pre>
<h4 id="use-cargo-doc"><a class="header" href="#use-cargo-doc">Use <code>cargo doc</code></a></h4>
<p>Alternatively you can just run <code>cargo doc</code> to have Cargo generate documentation
for your crate that contains the P4-generated Rust code. This will emit Rust
documentation that includes documentation for the generated code.</p>
<p>For example, in the main p4 repository that contains the vlan switch example
code, when you run <code>cargo doc</code> you'll see something like this</p>
<pre><code>$ cargo doc
[snip]
 Documenting x4c_error_codes v0.1.0 (/Users/ry/src/p4/x4c_error_codes)
 Documenting clap v3.2.23
 Documenting tests v0.1.0 (/Users/ry/src/p4/test)
 Documenting sidecar-lite v0.1.0 (/Users/ry/src/p4/lang/prog/sidecar-lite)
 Documenting p4-macro-test v0.1.0 (/Users/ry/src/p4/lang/p4-macro-test)
 Documenting x4c-book v0.1.0 (/Users/ry/src/p4/book/code)
 Documenting x4c v0.1.0 (/Users/ry/src/p4/x4c)
    Finished dev [unoptimized + debuginfo] target(s) in 15.87s
   Generated /Users/ry/src/p4/target/doc/p4_macro/index.html
   Generated /Users/ry/src/p4/target/doc/p4_macro_test/index.html
   Generated /Users/ry/src/p4/target/doc/p4_rust/index.html
   Generated /Users/ry/src/p4/target/doc/p4rs/index.html
   Generated /Users/ry/src/p4/target/doc/sidecar_lite/index.html
   Generated /Users/ry/src/p4/target/doc/tests/index.html
   Generated /Users/ry/src/p4/target/doc/x4c/index.html
   Generated /Users/ry/src/p4/target/doc/hello_world/index.html
   Generated /Users/ry/src/p4/target/doc/vlan_switch/index.html
   Generated /Users/ry/src/p4/target/doc/x4c_error_codes/index.html
</code></pre>
<p>If you open the file <code>target/doc/vlan_switch/index.html</code>. You'll see several
struct and function definitions. In particular, if you click on the
<code>main_pipeline</code> struct, you'll see methods associated with the main pipeline
like <code>add_ingress_fwd_fib_entry</code> that allow you to modify pipeline table state.</p>
<p>Now back to the control plane code above. You'll also notice that we are adding
key values and parameter values to the P4 tables as byte slices. At the time of
writing, <code>x4c</code> is not generating high-level table manipulation APIs so we have
to pass everything in as binary serialized data.</p>
<p>The semantics of these data buffers are the following.</p>
<ol>
<li>Both key data and match action data (parameters) are passed in in-order.</li>
<li>Numeric types are serialized in big-endian byte order.</li>
<li>If a set of keys or a set of parameters results in a size that does not land
on a byte-boundary, i.e. 12 bytes like we have in this example, the length of
the buffer is rounded up to the nearest byte boundary.</li>
</ol>
<p>After adding the forwarding entries, VLAN table entries are added in the same
manner. A VLAN with the <code>vid</code> of <code>47</code> is added to the first and second ports.
Note that we also use a table access method to get all the entries of a table
and print them out to convince ourselves our code is doing what we intend.</p>
<h3 id="test-code"><a class="header" href="#test-code">Test Code</a></h3>
<p>Now let's take a look at the test portion of our code.</p>
<pre><code class="language-rust">fn run_test(
    pipeline: main_pipeline,
    m2: [u8; 6],
    m3: [u8; 6],
) -&gt; Result&lt;(), anyhow::Error&gt; {
    // create and run the softnpu instance
    let mut npu = SoftNpu::new(NUM_PORTS.into(), pipeline, false);
    let phy1 = npu.phy(0);
    let phy2 = npu.phy(1);
    npu.run();

    // send a packet we expect to make it through
    phy1.send(&amp;[TxFrame::newv(m2, 0, b"blueberry", 47)])?;
    expect_frames!(phy2, &amp;[RxFrame::newv(phy1.mac, 0x8100, b"blueberry", 47)]);

    // send 3 packets, we expect the first 2 to get filtered by vlan rules
    phy1.send(&amp;[TxFrame::newv(m2, 0, b"poppyseed", 74)])?; // 74 != 47
    phy1.send(&amp;[TxFrame::new(m2, 0, b"banana")])?; // no tag
    phy1.send(&amp;[TxFrame::newv(m2, 0, b"muffin", 47)])?;
    phy1.send(&amp;[TxFrame::newv(m3, 0, b"nut", 47)])?; // no forwarding entry
    expect_frames!(phy2, &amp;[RxFrame::newv(phy1.mac, 0x8100, b"muffin", 47)]);

    Ok(())
}</code></pre>
<p>The first thing we do here is create a <code>SoftNpu</code> virtual ASIC instance with 2
ports that will execute the pipeline we configured with entries in the previous
section. We get references to each ASIC port and run the ASIC.</p>
<p>Next we send a few packets through the ASIC to validate that our P4 program is
doing what we expect given how we have configured the tables.</p>
<p>The first test passes through a packet we expect to make it through the VLAN
filtering. The next test sends 4 packets in the ASIC, but we expect our P4
program to filter 3 of them out.</p>
<ul>
<li>The first packet has the wrong <code>vid</code>.</li>
<li>The second packet has no <code>vid</code>.</li>
<li>The third packet should make it through.</li>
<li>The fourth packet has no forwarding entry.</li>
</ul>
<h4 id="running-the-test"><a class="header" href="#running-the-test">Running the test</a></h4>
<p>When we run this program we see the following</p>
<pre><code class="language-bash">$ cargo run --bin vlan-switch
    Finished dev [unoptimized + debuginfo] target(s) in 0.11s
     Running `target/debug/vlan-switch`
[
    TableEntry {
        action_id: "filter",
        keyset_data: [
            0,
            0,
        ],
        parameter_data: [
            0,
            47,
        ],
    },
]
[phy2] blueberry
drop
drop
drop
[phy2] muffin
</code></pre>
<p>The first thing we see is our little sanity check dumping out the VLAN table
after adding a single entry. This has what we expect, mapping the port <code>0</code> to
the <code>vid</code> <code>47</code>.</p>
<p>Next we start sending packets through the ASIC. There are two frame constructors
in play here. <code>TxFrame::newv</code> creates an Ethernet frame with a VLAN header and
<code>TxFrame::new</code> creates just a plane old Ethernet frame. The first argument to
each frame constructor is the destination MAC address. The second argument is
the ethertype to use and the third argument is the Ethernet payload.</p>
<p>Next we see that our blueberry packet made it through as expected. Then we see
three packets getting dropped as we expect. And finally we see the muffin packet
coming through as expected.</p>
<p>You can find this program in it's entirety
<a href="https://github.com/oxidecomputer/p4/blob/main/book/code/src/bin/vlan-switch.rs">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guidelines"><a class="header" href="#guidelines">Guidelines</a></h1>
<p>Ths chapter provides guidelines on various aspects of the <code>x4c</code> compiler.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="endianness"><a class="header" href="#endianness">Endianness</a></h1>
<p>The basic rules for endianness follow. Generally speaking numeric fields are in
big endian when they come in off the wire, little endian while in the program,
and transformed back to big endian on the way back out onto the wire. We refer
to this as confused endian.</p>
<ol>
<li>All numeric packet field data is big endian when enters and leaves a p4
program.</li>
<li>All numeric data, including packet fields is little endian inside a p4
program.</li>
<li>Table keys with the <code>exact</code> and <code>range</code> type defined over bit types are in
little endian.</li>
<li>Table keys with the <code>lpm</code> type are in the byte order they appear on the wire.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="https://storage.googleapis.com/goodwu-public/highlight.min.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
         window.addEventListener('load', function() {
             window.setTimeout(window.print, 100);
         });
        </script>

    </div>
    </body>
</html>
